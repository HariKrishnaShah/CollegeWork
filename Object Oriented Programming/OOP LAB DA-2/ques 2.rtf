{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red0\green120\blue215;\red128\green0\blue128;\red0\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title ques 2.rtf}}

\deflang1033\pard\plain\f0\fs26 \cf0 #include<iostream>
\par #include<cstdlib>
\par \cf1\b using\b0  \b namespace\b0  std\cf2\b ;
\par \b0\cf3\i //Hari Krishna Shah
\par /* This is a program to illustrate the overloading of operators.
\par */
\par \i0\cf1\b class\b0  Fraction
\par \cf2\b \{
\par \b0\cf1      \b public\cf2 :
\par \b0\cf1           \b int\b0  num\cf2\b ,\b0\cf1  deno\cf2\b ;
\par \b0\cf1      \b public\cf2 :
\par \b0\cf1           Fraction\cf2\b ()
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                num \cf2\b =\b0\cf1  \cf4 1\cf2\b ;
\par \b0\cf1                deno \cf2\b =\b0\cf1  \cf4 1\cf2\b ;
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           Fraction\cf2\b (\cf1 int\b0  n\cf2\b ,\b0\cf1  \b int\b0  d\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                num \cf2\b =\b0\cf1  n\cf2\b ;
\par \b0\cf1                \b if\b0  \cf2\b (\b0\cf1 d\cf2\b ==\b0\cf4 0\cf2\b )
\par \b0\cf1                \cf2\b \{
\par \b0\cf1                     cout \cf2\b <<\b0\cf1  \cf5\b "Error: Attempting to Divide by Zero"\b0\cf1  \cf2\b <<\b0\cf1  endl\cf2\b ;
\par \b0\cf1                     exit\cf2\b (\b0\cf4 0\cf2\b );\b0\cf1  \cf3\i // it will terminate the program if division by 0 is attempted
\par \i0\cf1                \cf2\b \}
\par \b0\cf1                \b else
\par \b0                     deno \cf2\b =\b0\cf1  d\cf2\b ;
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           Fraction \b operator\b0  \cf2\b +(\b0\cf1 Fraction f\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                \b int\b0  n \cf2\b =\b0\cf1  num\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b +\b0\cf1 f\cf2\b .\b0\cf1 num\cf2\b *\b0\cf1 deno\cf2\b ;
\par \b0\cf1                \b int\b0  d \cf2\b =\b0\cf1  deno\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b ;
\par \b0\cf1                \b return\b0  Fraction\cf2\b (\b0\cf1 n\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ),\b0\cf1 d\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ));
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           Fraction \b operator\b0  \cf2\b -(\b0\cf1 Fraction f\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                \b int\b0  n \cf2\b =\b0\cf1  num\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b -\b0\cf1 f\cf2\b .\b0\cf1 num\cf2\b *\b0\cf1 deno\cf2\b ;
\par \b0\cf1                \b int\b0  d \cf2\b =\b0\cf1  deno\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b ;
\par \b0\cf1                \b return\b0  Fraction\cf2\b (\b0\cf1 n\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ),\b0\cf1 d\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ));
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           Fraction \b operator\b0  \cf2\b *(\b0\cf1 Fraction f\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                \b int\b0  n \cf2\b =\b0\cf1  num\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 num\cf2\b ;
\par \b0\cf1                \b int\b0  d \cf2\b =\b0\cf1  deno\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b ;
\par \b0\cf1                \b return\b0  Fraction\cf2\b (\b0\cf1 n\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ),\b0\cf1 d\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ));
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           Fraction \b operator\b0  \cf2\b /(\b0\cf1 Fraction f\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                \b int\b0  n \cf2\b =\b0\cf1  num\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b ;
\par \b0\cf1                \b int\b0  d \cf2\b =\b0\cf1  deno\cf2\b *\b0\cf1 f\cf2\b .\b0\cf1 num\cf2\b ;
\par \b0\cf1                \b return\b0  Fraction\cf2\b (\b0\cf1 n\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ),\b0\cf1 d\cf2\b /\b0\cf1 gcd\cf2\b (\b0\cf1 n\cf2\b ,\b0\cf1 d\cf2\b ));
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           \b bool\b0  \b operator\b0  \cf2\b ==\b0\cf1  \cf2\b (\b0\cf1 Fraction \cf2\b &\b0\cf1 f\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                \b return\b0  \cf2\b (\b0\cf1 num\cf2\b ==\b0\cf1 f\cf2\b .\b0\cf1 num\cf2\b )\b0\cf1  \cf2\b &&\b0\cf1  \cf2\b (\b0\cf1 deno\cf2\b ==\b0\cf1 f\cf2\b .\b0\cf1 deno\cf2\b );
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           \b int\b0  gcd\cf2\b (\cf1 int\b0  n\cf2\b ,\b0\cf1  \b int\b0  d\cf2\b )
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                \b int\b0  rem\cf2\b ;
\par \b0\cf1                \b while\b0  \cf2\b (\b0\cf1 d \cf2\b !=\b0\cf1  \cf4 0\cf2\b )
\par \b0\cf1                \cf2\b \{
\par \b0\cf1                     rem \cf2\b =\b0\cf1  n \cf2\b %\b0\cf1  d\cf2\b ;
\par \b0\cf1                     n \cf2\b =\b0\cf1  d\cf2\b ;
\par \b0\cf1                     d \cf2\b =\b0\cf1  rem\cf2\b ;
\par \b0\cf1                \cf2\b \}
\par \b0\cf1                \b return\b0  n\cf2\b ;
\par \b0\cf1           \cf2\b \}
\par \b0\cf1           \b void\b0  accept\cf2\b ()
\par \b0\cf1           \cf2\b \{
\par \b0\cf1                cout\cf2\b <<\cf5 "\\n Enter Numerator     :  "\cf2 ;
\par \b0\cf1                cin\cf2\b >>\b0\cf1 num\cf2\b ;
\par \b0\cf1                cout\cf2\b <<\cf5 "\\n Enter Denominator   :  "\cf2 ;
\par \b0\cf1                cin\cf2\b >>\b0\cf1 deno\cf2\b ;
\par \b0\cf1           \cf2\b \}
\par \};
\par \cf1 int\b0  main\cf2\b ()
\par \{
\par \b0\cf1 	cout\cf2\b <<\cf5 " Digital Assignment Lab of OOP LAB"\cf2 <<\b0\cf1 endl\cf2\b ;
\par \b0\cf1 	\b class\b0  Fraction f\cf2\b [\b0\cf4 3\cf2\b ];
\par 
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n Enter the value for the 1st Fraction below\\n"\cf2 ;
\par 
\par \b0\cf1 	f\cf2\b [\b0\cf4 1\cf2\b ].\b0\cf1 accept\cf2\b ();
\par 
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n Enter the value for the second Fraction below\\n"\cf2 ;
\par \b0\cf1 	f\cf2\b [\b0\cf4 2\cf2\b ].\b0\cf1 accept\cf2\b ();
\par \b0\cf1 	
\par 	cout\cf2\b <<\cf5 "\\n -------------------------------------"\cf2 <<\b0\cf1 endl\cf2\b ;
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n The results of execution of overloaded arthimetic operators are given below: "\cf2 <<\b0\cf1 endl\cf2\b ;
\par 
\par \b0\cf1 	f\cf2\b [\b0\cf4 3\cf2\b ]=\b0\cf1 f\cf2\b [\b0\cf4 1\cf2\b ]+\b0\cf1 f\cf2\b [\b0\cf4 2\cf2\b ];
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n -------------------------------------"\cf2 ;
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n Sum of Two Numbers        : "\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 num\cf2\b <<\cf5 "/"\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 deno\cf2\b <<\b0\cf1 endl\cf2\b ;
\par 
\par \b0\cf1 	f\cf2\b [\b0\cf4 3\cf2\b ]=\b0\cf1 f\cf2\b [\b0\cf4 1\cf2\b ]-\b0\cf1 f\cf2\b [\b0\cf4 2\cf2\b ];
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n Difference of Two Numbers : "\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 num\cf2\b <<\cf5 "/"\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 deno\cf2\b <<\b0\cf1 endl\cf2\b ;
\par 
\par \b0\cf1 	f\cf2\b [\b0\cf4 3\cf2\b ]=\b0\cf1 f\cf2\b [\b0\cf4 1\cf2\b ]*\b0\cf1 f\cf2\b [\b0\cf4 2\cf2\b ];
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n Product of Two Numbers    : "\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 num\cf2\b <<\cf5 "/"\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 deno\cf2\b <<\b0\cf1 endl\cf2\b ;
\par 
\par \b0\cf1 	f\cf2\b [\b0\cf4 3\cf2\b ]=\b0\cf1 f\cf2\b [\b0\cf4 1\cf2\b ]/\b0\cf1 f\cf2\b [\b0\cf4 2\cf2\b ];
\par \b0\cf1 	cout\cf2\b <<\cf5 "\\n Division of Two Numbers   : "\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 num\cf2\b <<\cf5 "/"\cf2 <<\b0\cf1 f\cf2\b [\b0\cf4 3\cf2\b ].\b0\cf1 deno\cf2\b ;
\par 
\par 
\par \b0\cf1      \b return\b0  \cf4 0\cf2\b ;
\par \}
\par }
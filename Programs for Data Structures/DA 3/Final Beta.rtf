{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red0\green0\blue255;\red0\green120\blue215;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Final Beta.rtf}}

\deflang1033\pard\plain\f0\fs26 \cf0 #include <stdio.h>
\par #include <malloc.h>
\par 
\par \cf1\b int\b0  partition \cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  start\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b );
\par \cf1 void\b0  quick\cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  start\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b );
\par \cf1 void\b0  merge\cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  beg\cf2\b ,\b0\cf1  \b int\b0  mid\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b );
\par \cf1 void\b0  mergeSort\cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  beg\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b );
\par \cf1 void\b0  database_day_sort\cf2\b (\cf1 struct\b0  database \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  size\cf2\b );
\par 
\par \cf1 struct\b0  database\cf2\b \{
\par \b0\cf1 	\b int\b0  passport_id\cf2\b ;
\par \b0\cf1 	\b int\b0  day\cf2\b ;
\par \b0\cf1 	\b int\b0  month\cf2\b ;
\par \b0\cf1 	\b int\b0  year\cf2\b ;
\par \};
\par 
\par \cf1 struct\b0  today_record\cf2\b \{
\par \b0\cf1 	\b int\b0  passport_id\cf2\b ;
\par \b0\cf1 	\b int\b0  day\cf2\b ;
\par \b0\cf1 	\b int\b0  month\cf2\b ;
\par \b0\cf1 	\b int\b0  year\cf2\b ;
\par \};
\par 
\par \cf1 int\b0  main\cf2\b ()\{
\par \b0\cf1 	\b struct\b0  database \cf2\b *\b0\cf1 d\cf2\b ;
\par \b0\cf1 	\b struct\b0  today_record \cf2\b *\b0\cf1 r\cf2\b ;
\par \b0\cf1 	\b static\b0  \b int\b0  r_size \cf2\b =\b0\cf1  \cf3 0\cf2\b ,\b0\cf1  d_size \cf2\b =\b0\cf1  \cf3 0\cf2\b ;
\par \b0\cf1 	\b int\b0  option\cf2\b ,\b0\cf1  sort_choice\cf2\b ;
\par \b0\cf1 	d \cf2\b =\b0\cf1  \cf2\b (\cf1 struct\b0  database \cf2\b *)\b0\cf1  \cf2\b (\b0\cf1 malloc\cf2\b (\b0\cf1 d_size\cf2\b *\cf1 sizeof\cf2 (\cf1 struct\b0  database\cf2\b )));
\par 
\par \b0\cf1 	\b do\cf2 \{
\par \b0\cf1 		printf\cf2\b (\cf4 "\\nWelcome to the passport-id sorting algorithm.\\n"\cf2 );
\par \b0\cf1 		printf\cf2\b (\cf4 "Please choose an option from below menu.\\n \\
\par 		Enter 1 to display the total database \\n \\
\par 		Enter 2 to add today's passort-id to database\\n \\
\par 		Enter 3 to sort the database according to the renewal day\\n"\cf2 );
\par \b0\cf1 		printf\cf2\b (\cf4 "Enter your option here: "\cf2 );
\par \b0\cf1 		scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 option\cf2\b );
\par \b0\cf1 		printf\cf2\b (\cf4 "\\n"\cf2 );
\par 
\par \b0\cf1 		\b switch\cf2 (\b0\cf1 option\cf2\b )\{
\par \b0\cf1 			\b case\b0  \cf2\b -\b0\cf3 1\cf2\b :\{
\par \b0\cf1 				printf\cf2\b (\cf4 "The program exited successfully.\\n"\cf2 );
\par \b0\cf1 				\b break\cf2 ;
\par \b0\cf1 			\cf2\b \}
\par \b0\cf1 			\b case\b0  \cf3 1\cf2\b :\{
\par \b0\cf1 				\b if\cf2 (\b0\cf1 d_size \cf2\b ==\b0\cf1  \cf3 0\cf2\b )\{
\par \b0\cf1 					printf\cf2\b (\cf4 "Database empty.\\n"\cf2 );
\par \b0\cf1 				\cf2\b \}
\par \b0\cf1 				\b else\cf2 \{
\par \b0\cf1 					printf\cf2\b (\cf4 "The passports ids stored in the database are given below: \\n"\cf2 );
\par \b0\cf1 					\b for\cf2 (\cf1 int\b0  i \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  i\cf2\b <\b0\cf1 d_size\cf2\b ;\b0\cf1  i\cf2\b ++)\{
\par \b0\cf1 						printf\cf2\b (\cf4 "S.N: %d    Passport_ID: %d\\n"\cf2 ,\b0\cf1  i\cf2\b +\b0\cf3 1\cf2\b ,\b0\cf1  d\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id\cf2\b );
\par \b0\cf1 						printf\cf2\b (\cf4 "Renewed Data: %d-%d-%d"\cf2 ,\b0\cf1  d\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 day\cf2\b ,\b0\cf1  d\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 month\cf2\b ,\b0\cf1  d\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 year\cf2\b );
\par \b0\cf1 						printf\cf2\b (\cf4 "\\n\\n"\cf2 );
\par \b0\cf1 					\cf2\b \}
\par \b0\cf1 				\cf2\b \}
\par 
\par \b0\cf1 				\b break\cf2 ;
\par \b0\cf1 			\cf2\b \}
\par \b0\cf1 			\b case\b0  \cf3 2\cf2\b :\{
\par \b0\cf1 				free\cf2\b (\b0\cf1 r\cf2\b );
\par \b0\cf1 				printf\cf2\b (\cf4 "Enter the size of the today record: "\cf2 );
\par \b0\cf1 				scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 r_size\cf2\b );
\par \b0\cf1 				r \cf2\b =\b0\cf1  \cf2\b (\cf1 struct\b0  today_record \cf2\b *)\b0\cf1  \cf2\b (\b0\cf1 malloc\cf2\b (\b0\cf1 r_size\cf2\b *\cf1 sizeof\cf2 (\cf1 struct\b0  today_record\cf2\b )));
\par \b0\cf1 				d \cf2\b =\b0\cf1  \cf2\b (\cf1 struct\b0  database \cf2\b *)\b0\cf1  \cf2\b (\b0\cf1 realloc\cf2\b (\b0\cf1 d\cf2\b ,\b0\cf1  \cf2\b (\b0\cf1 d_size\cf2\b +\b0\cf1 r_size\cf2\b )*\cf1 sizeof\cf2 (\cf1 struct\b0  database\cf2\b )));
\par 
\par \b0\cf1 				\b for\cf2 (\cf1 int\b0  i \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  i\cf2\b <\b0\cf1 r_size\cf2\b ;\b0\cf1  i\cf2\b ++)\{
\par \b0\cf1 					printf\cf2\b (\cf4 "Enter the id number %d: "\cf2 ,\b0\cf1  i\cf2\b +\b0\cf3 1\cf2\b );
\par \b0\cf1 					scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id\cf2\b );
\par \b0\cf1 					printf\cf2\b (\cf4 "Enter the renwal day: "\cf2 );
\par \b0\cf1 					scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 day\cf2\b );
\par \b0\cf1 					printf\cf2\b (\cf4 "Enter the renewal month: "\cf2 );
\par \b0\cf1 					scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 month\cf2\b );
\par \b0\cf1 					printf\cf2\b (\cf4 "Enter the renewal year: "\cf2 );
\par \b0\cf1 					scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 year\cf2\b );
\par \b0\cf1 					printf\cf2\b (\cf4 "\\n\\n"\cf2 );
\par \b0\cf1 				\cf2\b \}
\par 
\par \b0\cf1 				\cf5\i // sorting
\par \i0\cf1 				printf\cf2\b (\cf4 "The details for today's record has accepted successfully.\\n"\cf2 );
\par \b0\cf1 				printf\cf2\b (\cf4 "Lets now sort the today's record and then store it in the database.\\n"\cf2 );
\par \b0\cf1 				printf\cf2\b (\cf4 "Enter 1 to sort the record by insertion sort.\\n"\cf2 );
\par \b0\cf1 				printf\cf2\b (\cf4 "Enter 2 to sort the record by selection sort\\n"\cf2 );
\par \b0\cf1 				printf\cf2\b (\cf4 "Enter 3 to sort by quick sort.\\n"\cf2 );
\par \b0\cf1 				printf\cf2\b (\cf4 "Enter 4 to sort by merger sort.\\n"\cf2 );
\par \b0\cf1 				printf\cf2\b (\cf4 "Enter your option here: "\cf2 );
\par \b0\cf1 				scanf\cf2\b (\cf4 "%d"\cf2 ,\b0\cf1  \cf2\b &\b0\cf1 sort_choice\cf2\b );
\par 
\par \b0\cf1 				\b switch\cf2 (\b0\cf1 sort_choice\cf2\b )\{
\par \b0\cf1 					\b case\b0  \cf3 1\cf2\b :\{
\par \b0\cf1 						\b int\b0  i\cf2\b ,\b0\cf1  key\cf2\b ,\b0\cf1  j\cf2\b ;
\par \b0\cf1 					    \b for\b0  \cf2\b (\b0\cf1 i \cf2\b =\b0\cf1  \cf3 1\cf2\b ;\b0\cf1  i \cf2\b <\b0\cf1  r_size\cf2\b ;\b0\cf1  i\cf2\b ++)\b0\cf1  \cf2\b \{
\par \b0\cf1 					        key \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id\cf2\b ;
\par \b0\cf1 					        j \cf2\b =\b0\cf1  i \cf2\b -\b0\cf1  \cf3 1\cf2\b ;
\par \b0\cf1 					        \b while\b0  \cf2\b (\b0\cf1 j \cf2\b >=\b0\cf1  \cf3 0\cf1  \cf2\b &&\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id \cf2\b >\b0\cf1  key\cf2\b )\b0\cf1  \cf2\b \{
\par \b0\cf1 					            r\cf2\b [\b0\cf1 j \cf2\b +\b0\cf1  \cf3 1\cf2\b ].\b0\cf1 passport_id \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 passport_id\cf2\b ;
\par \b0\cf1 					            r\cf2\b [\b0\cf1 j \cf2\b +\b0\cf1  \cf3 1\cf2\b ].\b0\cf1 day \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 day\cf2\b ;
\par \b0\cf1 					            r\cf2\b [\b0\cf1 j \cf2\b +\b0\cf1  \cf3 1\cf2\b ].\b0\cf1 month \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 month\cf2\b ;
\par \b0\cf1 					            r\cf2\b [\b0\cf1 j \cf2\b +\b0\cf1  \cf3 1\cf2\b ].\b0\cf1 year \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 year\cf2\b ;
\par 
\par \b0\cf1 					            j \cf2\b =\b0\cf1  j \cf2\b -\b0\cf1  \cf3 1\cf2\b ;
\par \b0\cf1 					        \cf2\b \}
\par \b0\cf1 					        r\cf2\b [\b0\cf1 j \cf2\b +\b0\cf1  \cf3 1\cf2\b ].\b0\cf1 passport_id \cf2\b =\b0\cf1  key\cf2\b ;
\par \b0\cf1 					    \cf2\b \}
\par 
\par \b0\cf1 						\b break\cf2 ;
\par \b0\cf1 					\cf2\b \}
\par \b0\cf1 					\b case\b0  \cf3 2\cf2\b :\{
\par \b0\cf1 					\b struct\b0  today_record temp\cf2\b ;
\par \b0\cf1 					\b for\cf2 (\cf1 int\b0  i \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  i\cf2\b <\b0\cf1 r_size\cf2\b ;\b0\cf1  i\cf2\b ++)\{
\par \b0\cf1 						\b for\cf2 (\cf1 int\b0  j \cf2\b =\b0\cf1  i\cf2\b +\b0\cf3 1\cf2\b ;\b0\cf1  j\cf2\b <\b0\cf1 r_size\cf2\b ;\b0\cf1  j\cf2\b ++)\{
\par \b0\cf1 							\b if\cf2 (\b0\cf1 r\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 passport_id\cf2\b <\b0\cf1 r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id\cf2\b )\{
\par \b0\cf1 								temp \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ];
\par \b0\cf1 								r\cf2\b [\b0\cf1 i\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 j\cf2\b ];
\par \b0\cf1 								r\cf2\b [\b0\cf1 j\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  temp\cf2\b ;
\par \b0\cf1 							\cf2\b \}
\par \b0\cf1 						\cf2\b \}
\par \b0\cf1 					\cf2\b \}
\par \b0\cf1 					\b break\cf2 ;
\par \b0\cf1 				\cf2\b \}
\par 
\par \b0\cf1 				\b case\b0  \cf3 3\cf2\b :\{
\par \b0\cf1 					quick\cf2\b (\b0\cf1 r\cf2\b ,\b0\cf1  \cf3 0\cf2\b ,\b0\cf1  r_size \cf2\b -\b0\cf1  \cf3 1\cf2\b );
\par \b0\cf1 					\b break\cf2 ;
\par \b0\cf1 				\cf2\b \}
\par 
\par \b0\cf1 				\b case\b0  \cf3 4\cf2\b :\{
\par \b0\cf1 					mergeSort\cf2\b (\b0\cf1 r\cf2\b ,\b0\cf1  \cf3 0\cf2\b ,\b0\cf1  r_size\cf2\b -\b0\cf3 1\cf2\b );
\par \b0\cf1 					\b break\cf2 ;
\par \b0\cf1 				\cf2\b \}
\par 
\par 
\par \b0\cf1 				\cf2\b \}
\par \b0\cf1 				printf\cf2\b (\cf4 "\\nThe array has been sorted successfully.\\n"\cf2 );
\par \b0\cf1 				\cf5\i //After sorting copying the sorted record in the database
\par \i0\cf1 				\b for\cf2 (\cf1 int\b0  i \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  i\cf2\b <\b0\cf1 r_size\cf2\b ;\b0\cf1  i\cf2\b ++)\{
\par \b0\cf1 					d\cf2\b [\b0\cf1 d_size\cf2\b ].\b0\cf1 passport_id \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id\cf2\b ;
\par \b0\cf1 					d\cf2\b [\b0\cf1 d_size\cf2\b ].\b0\cf1 day \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 day\cf2\b ;
\par \b0\cf1 					d\cf2\b [\b0\cf1 d_size\cf2\b ].\b0\cf1 month \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 month\cf2\b ;
\par \b0\cf1 					d\cf2\b [\b0\cf1 d_size\cf2\b ].\b0\cf1 year \cf2\b =\b0\cf1  r\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 year\cf2\b ;
\par \b0\cf1 					d_size \cf2\b +=\b0\cf1  \cf3 1\cf2\b ;
\par \b0\cf1 				\cf2\b \}
\par 
\par 
\par 
\par \b0\cf1 				\b break\cf2 ;
\par \b0\cf1 			\cf2\b \}
\par \b0\cf1 			
\par 			\b case\b0  \cf3 3\cf2\b :\{
\par \b0\cf1 				database_day_sort\cf2\b (\b0\cf1 d\cf2\b ,\b0\cf1  d_size\cf2\b );
\par \b0\cf1 				\b break\cf2 ;
\par \b0\cf1 			\cf2\b \}
\par 
\par 
\par \b0\cf1 			printf\cf2\b (\cf4 "\\n"\cf2 );
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 	\cf2\b \}
\par \b0\cf1 	\b while\cf2 (\b0\cf1 option\cf2\b !=\b0\cf1  \cf2\b -\b0\cf3 1\cf2\b );
\par \}
\par 
\par 
\par \b0\cf5\i //quick sort
\par \i0\cf1\b int\b0  partition \cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  start\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b )
\par \{
\par \b0\cf1     \b int\b0  pivot \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 end\cf2\b ].\b0\cf1 passport_id\cf2\b ;\b0\cf1  \cf5\i // pivot element
\par \i0\cf1     \b int\b0  i \cf2\b =\b0\cf1  \cf2\b (\b0\cf1 start \cf2\b -\b0\cf1  \cf3 1\cf2\b );
\par \b0\cf1     \b struct\b0  today_record temp\cf2\b ;
\par 
\par \b0\cf1     \b for\b0  \cf2\b (\cf1 int\b0  j \cf2\b =\b0\cf1  start\cf2\b ;\b0\cf1  j \cf2\b <=\b0\cf1  end \cf2\b -\b0\cf1  \cf3 1\cf2\b ;\b0\cf1  j\cf2\b ++)
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \cf5\i // If current element is smaller than the pivot
\par \i0\cf1         \b if\b0  \cf2\b (\b0\cf1 a\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 passport_id \cf2\b <\b0\cf1  pivot\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             i\cf2\b ++;\b0\cf1  \cf5\i // increment index of smaller element
\par \i0\cf1             temp\cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 i\cf2\b ];
\par \b0\cf1             a\cf2\b [\b0\cf1 i\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 j\cf2\b ];
\par \b0\cf1             a\cf2\b [\b0\cf1 j\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  temp\cf2\b ;
\par \b0\cf1         \cf2\b \}
\par \b0\cf1     \cf2\b \}
\par \b0\cf1     temp \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 i\cf2\b +\b0\cf3 1\cf2\b ];
\par \b0\cf1     a\cf2\b [\b0\cf1 i\cf2\b +\b0\cf3 1\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 end\cf2\b ];
\par \b0\cf1     a\cf2\b [\b0\cf1 end\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  temp\cf2\b ;
\par \b0\cf1     \b return\b0  \cf2\b (\b0\cf1 i \cf2\b +\b0\cf1  \cf3 1\cf2\b );
\par \}
\par 
\par \b0\cf5\i /* function to implement quick sort */
\par \i0\cf1\b void\b0  quick\cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  start\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b )\b0\cf1  \cf5\i /* a[] = array to be sorted, start = Starting index, end = Ending index */
\par \i0\cf2\b \{
\par \b0\cf1     \b if\b0  \cf2\b (\b0\cf1 start \cf2\b <\b0\cf1  end\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b int\b0  p \cf2\b =\b0\cf1  partition\cf2\b (\b0\cf1 a\cf2\b ,\b0\cf1  start\cf2\b ,\b0\cf1  end\cf2\b );\b0\cf1  \cf5\i //p is the partitioning index
\par \i0\cf1         quick\cf2\b (\b0\cf1 a\cf2\b ,\b0\cf1  start\cf2\b ,\b0\cf1  p \cf2\b -\b0\cf1  \cf3 1\cf2\b );
\par \b0\cf1         quick\cf2\b (\b0\cf1 a\cf2\b ,\b0\cf1  p \cf2\b +\b0\cf1  \cf3 1\cf2\b ,\b0\cf1  end\cf2\b );
\par \b0\cf1     \cf2\b \}
\par \}
\par 
\par \b0\cf5\i //Merge Sort
\par \i0\cf1\b void\b0  merge\cf2\b (\cf1 struct\b0  today_record \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  beg\cf2\b ,\b0\cf1  \b int\b0  mid\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b )
\par \{
\par \b0\cf1     \b int\b0  i\cf2\b ,\b0\cf1  j\cf2\b ,\b0\cf1  k\cf2\b ;
\par \b0\cf1     \b int\b0  n1 \cf2\b =\b0\cf1  mid \cf2\b -\b0\cf1  beg \cf2\b +\b0\cf1  \cf3 1\cf2\b ;
\par \b0\cf1     \b int\b0  n2 \cf2\b =\b0\cf1  end \cf2\b -\b0\cf1  mid\cf2\b ;
\par 
\par \b0\cf1     \b struct\b0  today_record LeftArray\cf2\b [\b0\cf1 n1\cf2\b ],\b0\cf1  RightArray\cf2\b [\b0\cf1 n2\cf2\b ];\b0\cf1  \cf5\i //temporary arrays
\par 
\par \i0\cf1     \cf5\i /* copy data to temp arrays */
\par \i0\cf1     \b for\b0  \cf2\b (\cf1 int\b0  i \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  i \cf2\b <\b0\cf1  n1\cf2\b ;\b0\cf1  i\cf2\b ++)
\par \b0\cf1     LeftArray\cf2\b [\b0\cf1 i\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 beg \cf2\b +\b0\cf1  i\cf2\b ];
\par \b0\cf1     \b for\b0  \cf2\b (\cf1 int\b0  j \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  j \cf2\b <\b0\cf1  n2\cf2\b ;\b0\cf1  j\cf2\b ++)
\par \b0\cf1     RightArray\cf2\b [\b0\cf1 j\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 mid \cf2\b +\b0\cf1  \cf3 1\cf1  \cf2\b +\b0\cf1  j\cf2\b ];
\par 
\par \b0\cf1     i \cf2\b =\b0\cf1  \cf3 0\cf2\b ,\b0\cf1  \cf5\i /* initial index of first sub-array */
\par \i0\cf1     j \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  \cf5\i /* initial index of second sub-array */
\par \i0\cf1     k \cf2\b =\b0\cf1  beg\cf2\b ;\b0\cf1   \cf5\i /* initial index of merged sub-array */
\par 
\par \i0\cf1     \b while\b0  \cf2\b (\b0\cf1 i \cf2\b <\b0\cf1  n1 \cf2\b &&\b0\cf1  j \cf2\b <\b0\cf1  n2\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b if\cf2 (\b0\cf1 LeftArray\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 passport_id \cf2\b <\b0\cf1  RightArray\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 passport_id\cf2\b )
\par \b0\cf1         \cf2\b \{
\par \b0\cf1             a\cf2\b [\b0\cf1 k\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  LeftArray\cf2\b [\b0\cf1 i\cf2\b ];
\par \b0\cf1             i\cf2\b ++;
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         \b else
\par \b0         \cf2\b \{
\par \b0\cf1             a\cf2\b [\b0\cf1 k\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  RightArray\cf2\b [\b0\cf1 j\cf2\b ];
\par \b0\cf1             j\cf2\b ++;
\par \b0\cf1         \cf2\b \}
\par \b0\cf1         k\cf2\b ++;
\par \b0\cf1     \cf2\b \}
\par \b0\cf1     \b while\b0  \cf2\b (\b0\cf1 i\cf2\b <\b0\cf1 n1\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         a\cf2\b [\b0\cf1 k\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  LeftArray\cf2\b [\b0\cf1 i\cf2\b ];
\par \b0\cf1         i\cf2\b ++;
\par \b0\cf1         k\cf2\b ++;
\par \b0\cf1     \cf2\b \}
\par 
\par \b0\cf1     \b while\b0  \cf2\b (\b0\cf1 j\cf2\b <\b0\cf1 n2\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         a\cf2\b [\b0\cf1 k\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  RightArray\cf2\b [\b0\cf1 j\cf2\b ];
\par \b0\cf1         j\cf2\b ++;
\par \b0\cf1         k\cf2\b ++;
\par \b0\cf1     \cf2\b \}
\par \}
\par \cf1 void\b0  mergeSort\cf2\b (\cf1 struct\b0  today_record\cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  beg\cf2\b ,\b0\cf1  \b int\b0  end\cf2\b )
\par \{
\par \b0\cf1     \b if\b0  \cf2\b (\b0\cf1 beg \cf2\b <\b0\cf1  end\cf2\b )
\par \b0\cf1     \cf2\b \{
\par \b0\cf1         \b int\b0  mid \cf2\b =\b0\cf1  \cf2\b (\b0\cf1 beg \cf2\b +\b0\cf1  end\cf2\b )\b0\cf1  \cf2\b /\b0\cf1  \cf3 2\cf2\b ;
\par \b0\cf1         mergeSort\cf2\b (\b0\cf1 a\cf2\b ,\b0\cf1  beg\cf2\b ,\b0\cf1  mid\cf2\b );
\par \b0\cf1         mergeSort\cf2\b (\b0\cf1 a\cf2\b ,\b0\cf1  mid \cf2\b +\b0\cf1  \cf3 1\cf2\b ,\b0\cf1  end\cf2\b );
\par \b0\cf1         merge\cf2\b (\b0\cf1 a\cf2\b ,\b0\cf1  beg\cf2\b ,\b0\cf1  mid\cf2\b ,\b0\cf1  end\cf2\b );
\par \b0\cf1     \cf2\b \}
\par \}
\par 
\par \b0\cf5\i //sorting according to the day
\par 
\par \i0\cf1\b void\b0  database_day_sort\cf2\b (\cf1 struct\b0  database \cf2\b *\b0\cf1 a\cf2\b ,\b0\cf1  \b int\b0  size\cf2\b )\{
\par \b0\cf1 	\b struct\b0  database temp\cf2\b ;
\par \b0\cf1 	\b for\cf2 (\cf1 int\b0  i \cf2\b =\b0\cf1  \cf3 0\cf2\b ;\b0\cf1  i\cf2\b <\b0\cf1 size\cf2\b ;\b0\cf1  i\cf2\b ++)\{
\par \b0\cf1 		\b for\cf2 (\cf1 int\b0  j \cf2\b =\b0\cf1  i\cf2\b +\b0\cf3 1\cf2\b ;\b0\cf1  j\cf2\b <\b0\cf1 size\cf2\b ;\b0\cf1  j\cf2\b ++)\{
\par \b0\cf1 			\b if\cf2 (\b0\cf1 a\cf2\b [\b0\cf1 j\cf2\b ].\b0\cf1 day \cf2\b <\b0\cf1  a\cf2\b [\b0\cf1 i\cf2\b ].\b0\cf1 day\cf2\b )\{
\par \b0\cf1 				temp \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 i\cf2\b ];
\par \b0\cf1 				a\cf2\b [\b0\cf1 i\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  a\cf2\b [\b0\cf1 j\cf2\b ];
\par \b0\cf1 				a\cf2\b [\b0\cf1 j\cf2\b ]\b0\cf1  \cf2\b =\b0\cf1  temp\cf2\b ;
\par \b0\cf1 			\cf2\b \}
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 	\cf2\b \}
\par \b0\cf1 	printf\cf2\b (\cf4 "The database has been sorted successfully according to the renewal day.\\n"\cf2 );
\par \}
\par 
\par 
\par 
\par 
\par }
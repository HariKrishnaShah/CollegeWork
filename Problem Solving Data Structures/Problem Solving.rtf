{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red0\green120\blue215;\red0\green0\blue0;\red255\green0\blue0;\red128\green0\blue128;\red0\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Problem Solving.rtf}}

\deflang1033\pard\plain\f0\fs28 \cf0 #include<stdio.h>
\par #include <malloc.h>
\par \cf1\i //Coded by Hari Krishna Shah
\par 
\par \i0\cf2\b struct\b0  Node
\par \cf3\b \{
\par \b0\cf2    \b int\b0  data\cf3\b ;
\par \b0\cf2    \b struct\b0  Node \cf3\b *\b0\cf2 next\cf3\b ;
\par \};
\par 
\par \cf2 void\b0  push\cf3\b (\cf2 int\cf3 );
\par \cf2 void\b0  pop\cf3\b ();
\par \cf2 void\b0  display\cf3\b ();
\par \cf2 struct\b0  Node \cf3\b *\b0\cf2 top \cf3\b =\b0\cf2  NULL\cf3\b ;
\par 
\par \b0\cf1\i // Creating a temporary stack to save the stack in reverse order and to display in reverse order.
\par //Using the same struct Node for a new stack
\par 
\par \i0\cf2\b struct\b0  Node \cf3\b *\b0\cf2 reverse_top \cf3\b =\b0\cf2  NULL\cf3\b ;
\par \cf2 void\b0  push_reverse\cf3\b (\cf2 int\cf3 );
\par \cf2 void\b0  reverse\cf3\b ();
\par 
\par \cf2 int\b0  main\cf3\b ()
\par \{
\par \b0\cf2    \b int\b0  choice \cf3\b =\b0\cf2  \cf4 0\cf3\b ,\b0\cf2  value\cf3\b ;
\par \b0\cf2    printf\cf3\b (\cf5 "\\nThis is stack implementation using linked list.\\n"\cf3 );
\par \b0\cf2    \b while\cf3 (\b0\cf2 choice \cf3\b !=\b0\cf2  \cf4 4\cf3\b )\{
\par \b0\cf2       printf\cf3\b (\cf5 "\\n\\t\\t****** This program is made by Hari Krishna Shah ******\\n"\cf3 );
\par \b0\cf2       printf\cf3\b (\cf5 "Welcome to the main menu. \\n \\
\par 	  Enter 1 for push operation\\n \\
\par 	  Enter 2 for pop operation\\n \\
\par 	  Enter 3 to display the stack in reverse order\\n \\
\par 	  Enter 4 to exit the stack\\n"\cf3 );
\par \b0\cf2 	  printf\cf3\b (\cf5 "Enter your choice here: "\cf3 );
\par \b0\cf2       scanf\cf3\b (\cf5 "%d"\cf3 ,&\b0\cf2 choice\cf3\b );
\par \b0\cf2       \b switch\cf3 (\b0\cf2 choice\cf3\b )\{
\par \b0\cf2 	 \b case\b0  \cf4 1\cf3\b :\{
\par \b0\cf2 	 	printf\cf3\b (\cf5 "Enter the value to be insert: "\cf3 );
\par \b0\cf2 		 scanf\cf3\b (\cf5 "%d"\cf3 ,\b0\cf2  \cf3\b &\b0\cf2 value\cf3\b );
\par \b0\cf2 		 push\cf3\b (\b0\cf2 value\cf3\b );
\par \b0\cf2 		\b break\cf3 ;
\par \b0\cf2 	 \cf3\b \}
\par \b0\cf2 	 \b case\b0  \cf4 2\cf3\b :\{
\par \b0\cf2 	 	pop\cf3\b ();
\par \b0\cf2 		\b break\cf3 ;
\par \b0\cf2 	 \cf3\b \}
\par \b0\cf2 	 \b case\b0  \cf4 3\cf3\b :\{
\par \b0\cf2 	 	reverse\cf3\b ();
\par \b0\cf2 	 	display\cf3\b ();
\par \b0\cf2 		\b break\cf3 ;
\par \b0\cf2 	 \cf3\b \}
\par \b0\cf2 	 \b case\b0  \cf4 4\cf3\b :\{
\par \b0\cf2 	 	printf\cf3\b (\cf5 "Thank you for using the program. This code is made by Hari Krishna Shah with love.\\n"\cf3 );
\par \b0\cf2 		\b break\cf3 ;
\par \b0\cf2 	 \cf3\b \}
\par \b0\cf2 	 \b default\cf3 :\b0\cf2  printf\cf3\b (\cf5 "\\nPlease enter a valid option and try again.\\n"\cf3 );
\par \b0\cf2       \cf3\b \}
\par \b0\cf2       printf\cf3\b (\cf5 "\\n"\cf3 );
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    \b return\b0  \cf4 0\cf3\b ;
\par \}
\par \cf2 void\b0  push\cf3\b (\cf2 int\b0  value\cf3\b )
\par \{
\par \b0\cf2    \b struct\b0  Node \cf3\b *\b0\cf2 newNode\cf3\b ;
\par \b0\cf2    newNode \cf3\b =\b0\cf2  \cf3\b (\cf2 struct\b0  Node\cf3\b *)\b0\cf2 malloc\cf3\b (\cf2 sizeof\cf3 (\cf2 struct\b0  Node\cf3\b ));
\par \b0\cf2    newNode\cf3\b ->\b0\cf2 data \cf3\b =\b0\cf2  value\cf3\b ;
\par \b0\cf2    \b if\cf3 (\b0\cf2 top \cf3\b ==\b0\cf2  NULL\cf3\b )\{
\par \b0\cf2    	newNode\cf3\b ->\b0\cf2 next \cf3\b =\b0\cf2  NULL\cf3\b ;
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    \b else\cf3 \{
\par \b0\cf2    	newNode\cf3\b ->\b0\cf2 next \cf3\b =\b0\cf2  top\cf3\b ;
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    top \cf3\b =\b0\cf2  newNode\cf3\b ;
\par \b0\cf2    printf\cf3\b (\cf5 "\\nInsertion is Successful!!!\\n"\cf3 );
\par \}
\par \cf2 void\b0  pop\cf3\b ()
\par \{
\par \b0\cf2    \b if\cf3 (\b0\cf2 top \cf3\b ==\b0\cf2  NULL\cf3\b )
\par \b0\cf2       printf\cf3\b (\cf5 "\\nStack is Empty!!!\\n"\cf3 );
\par \b0\cf2    \b else\cf3 \{
\par \b0\cf2       \b struct\b0  Node \cf3\b *\b0\cf2 temp \cf3\b =\b0\cf2  top\cf3\b ;
\par \b0\cf2       printf\cf3\b (\cf5 "\\nDeleted element: %d"\cf3 ,\b0\cf2  temp\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2       top \cf3\b =\b0\cf2  temp\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2       free\cf3\b (\b0\cf2 temp\cf3\b );
\par \b0\cf2    \cf3\b \}
\par \}
\par \cf2 void\b0  display\cf3\b ()
\par \{
\par \b0\cf2    \b if\cf3 (\b0\cf2 reverse_top \cf3\b ==\b0\cf2  NULL\cf3\b )\{
\par \b0\cf2    	 printf\cf3\b (\cf5 "\\nStack is Empty!!!\\n"\cf3 );
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    \b else\cf3 \{
\par \b0\cf2       \b struct\b0  Node \cf3\b *\b0\cf2 temp \cf3\b =\b0\cf2  reverse_top\cf3\b ;
\par \b0\cf2       \b while\cf3 (\b0\cf2 temp\cf3\b ->\b0\cf2 next \cf3\b !=\b0\cf2  NULL\cf3\b )\{
\par \b0\cf2 		 printf\cf3\b (\cf5 "%d--->"\cf3 ,\b0\cf2 temp\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2 		 temp \cf3\b =\b0\cf2  temp \cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2       \cf3\b \}
\par \b0\cf2       printf\cf3\b (\cf5 "%d"\cf3 ,\b0\cf2 temp\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2    \cf3\b \}
\par \}
\par \cf2 void\b0  push_reverse\cf3\b (\cf2 int\b0  value\cf3\b )\{
\par \b0\cf2 	\b struct\b0  Node \cf3\b *\b0\cf2 newNode\cf3\b ;
\par \b0\cf2    newNode \cf3\b =\b0\cf2  \cf3\b (\cf2 struct\b0  Node\cf3\b *)\b0\cf2 malloc\cf3\b (\cf2 sizeof\cf3 (\cf2 struct\b0  Node\cf3\b ));
\par \b0\cf2    newNode\cf3\b ->\b0\cf2 data \cf3\b =\b0\cf2  value\cf3\b ;
\par \b0\cf2    \b if\cf3 (\b0\cf2 reverse_top \cf3\b ==\b0\cf2  NULL\cf3\b )\{
\par \b0\cf2    	newNode\cf3\b ->\b0\cf2 next \cf3\b =\b0\cf2  NULL\cf3\b ;
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    \b else\cf3 \{
\par \b0\cf2    	newNode\cf3\b ->\b0\cf2 next \cf3\b =\b0\cf2  reverse_top\cf3\b ;
\par \b0\cf2    \cf3\b \}
\par \b0\cf2    reverse_top \cf3\b =\b0\cf2  newNode\cf3\b ;
\par \}
\par \cf2 void\b0  reverse\cf3\b ()\{
\par \b0\cf2 	\b if\cf3 (\b0\cf2 top \cf3\b ==\b0\cf2  NULL\cf3\b )\{
\par \b0\cf2 		reverse_top \cf3\b =\b0\cf2  NULL\cf3\b ;
\par \b0\cf2 	\cf3\b \}
\par \b0\cf2 	\b else\cf3 \{
\par \b0\cf2 		\b struct\b0  Node \cf3\b *\b0\cf2 temp \cf3\b =\b0\cf2  top\cf3\b ;
\par \b0\cf2 		\b while\cf3 (\b0\cf2 temp\cf3\b ->\b0\cf2 next \cf3\b !=\b0\cf2  NULL\cf3\b )\{
\par \b0\cf2 			push_reverse\cf3\b (\b0\cf2 temp\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2 			temp \cf3\b =\b0\cf2  temp\cf3\b ->\b0\cf2 next\cf3\b ;
\par \b0\cf2 		\cf3\b \}
\par \b0\cf2 		push_reverse\cf3\b (\b0\cf2 temp\cf3\b ->\b0\cf2 data\cf3\b );
\par \b0\cf2 	\cf3\b \}
\par 
\par \}
\par }